(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{212:function(t,r,e){"use strict";e.r(r);var a=e(7),n=Object(a.a)({},function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"ioc-inversion-of-control-控制反转"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc-inversion-of-control-控制反转","aria-hidden":"true"}},[t._v("#")]),t._v(" IOC(Inversion of Control)控制反转")]),t._v(" "),e("p",[t._v("IOC是对象之间解耦的理论思想，2004年，Martin Fowler探讨了同一个问题，既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，他得出了答案：“获得依赖对象的过程被反转了”。控制被反转之后，获得依赖对象的过程由自身管理变为了由IOC容器主动注入。于是，他给“控制反转”取了一个更合适的名字叫做“依赖注入（Dependency Injection）”。他的这个答案，实际上给出了实现IOC的方法：注入。所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。")]),t._v(" "),e("h1",{attrs:{id:"ioc理解的我认为关键点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ioc理解的我认为关键点","aria-hidden":"true"}},[t._v("#")]),t._v(" IOC理解的我认为关键点")]),t._v(" "),e("ul",[e("li",[t._v("低耦合和无耦合的好处就是不需要关心其它类的实现，只要实现好自己就行。")]),t._v(" "),e("li",[t._v("控制反转，主动获取对象变成被动取得，获得依赖对象的过程被反转了")]),t._v(" "),e("li",[t._v("依赖注入，依赖的对象通过注入的方式获得。")]),t._v(" "),e("li",[t._v("实现IOC理论的类，可以看成一个工厂容器，IOC理论又可以说是一个工厂设计模式。")]),t._v(" "),e("li",[t._v("Java中实现IOC理论是通过反射和xml文件实现的，通过反射获取xml中的配置创建对应对象，注入到需要创建的类中。")]),t._v(" "),e("li",[t._v("xml配置相对于Java代码来说，更灵活和易于扩展。")])]),t._v(" "),e("h1",{attrs:{id:"参考资料"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考资料","aria-hidden":"true"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://www.cnblogs.com/superjt/p/4311577.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Spring的IOC原理[通俗解释一下]"),e("OutboundLink")],1)])])])},[],!1,null,null,null);r.default=n.exports}}]);